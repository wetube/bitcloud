#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "bitcloud.h"

#include "nodepool_sql.h"

sqlite3 *nodepool;

/*
 Opens the nodepool db.
 If it doesn't exist, it creates all the necessary tables.
*/

BCError bc_open_nodepool (const char* filename)
{
  int rc;
  char *err;

  rc = sqlite3_open_v2(filename, &nodepool, SQLITE_OPEN_READWRITE, NULL);
  if (rc) { /* file doesn't exist yet or is readonly */
    sqlite3_close (nodepool);
    rc = sqlite3_open(filename, &nodepool);
    if (rc) {
      sqlite3_close (nodepool);
      nodepool = NULL;
      bc_log(BC_DB_ERROR,
             "could not create the db: %s",
             sqlite3_errmsg(nodepool));
      return (BC_DB_ERROR);
    }
    /* Create all the tables in the nodepool.sql file. nodepool_sql.h was
       generated by xxd utility in the Makefile to include the SQL source into
       the executable. */
    nodepool_sql[nodepool_sql_len] = 0; /* <-- because xxd doesn't end the
                                           string in NULL. Look Makefile. */
    rc = sqlite3_exec (nodepool, (const char*)nodepool_sql,NULL,NULL, &err);
    if (rc != SQLITE_OK) {
      sqlite3_free (err);
      sqlite3_close (nodepool);
      remove (filename);
      nodepool = NULL;
      bc_log (BC_DB_ERROR, "%s", err);
      return (BC_DB_ERROR);
    }
    bc_log (BC_OK, "Nodepool created");
  }

  return BC_OK;
}



/* general authorization callback function for sqlite */

BCError bc_auth (void *user_data,
                 int event_code,
                 const char *event_spec,
                 const char *event_spec2,
                 const char *db_name,
                 const char *trigger)
{
  switch (event_code) {
    default:
      return SQLITE_DENY;
    }
  return SQLITE_DENY;
}

int BC_log_to_stdout = 1;
int BC_exit_on_sql_error = 1;

void bc_log (BCError error, const char *msg, ...)
{
  va_list args;
  char buffer[BC_MAX_LOG_SIZE];

  va_start(args, msg);
  vsnprintf (buffer, BC_MAX_LOG_SIZE, msg, args);
  va_end(args);

  if (BC_log_to_stdout) {
    if (error!=BC_OK) printf ("ERROR %d: ", error);
    printf ("%s\n", buffer);
  }

  /* log into the nodepool: */
  if (nodepool) {
    /* static variables and prepared statements to make it faster:*/
    static sqlite3_stmt *stmt;
    static char *sql = "INSERT INTO logs(error_code,log) VALUES(?,?)";
    static const char *tail;
    static int rc = -1;

    if (rc==-1) {
      rc = sqlite3_prepare(nodepool, sql, strlen(sql), &stmt, &tail);

      if (rc!=SQLITE_OK) {
        fprintf (stderr, "FATAL: error in the database, cannot log.\n");
        sqlite3_close (nodepool);
        exit(rc);
      }
    }

    sqlite3_bind_int(stmt, 1, error);
    sqlite3_bind_text(stmt, 2, buffer, -1, SQLITE_STATIC);

    sqlite3_step(stmt);

    int reset_err = sqlite3_reset(stmt);
    if (reset_err) {
      fprintf (stderr,
               "FATAL: database error (SQLite error %d).\n",
               reset_err);
      exit(BC_DB_ERROR);
    }

    if (BC_exit_on_sql_error && (error == BC_BAD_SQL)) {
      sqlite3_close (nodepool);
      exit (BC_BAD_SQL);
    }
  }
}


BCError bc_sql (BCStmt *stmt, const char* sql)
{
  if (sqlite3_prepare(nodepool, sql, strlen(sql), stmt, NULL)) {
    bc_log (BC_BAD_SQL,
            "bad SQL statement: %s",
            (const char*) sqlite3_errmsg(nodepool));
    return BC_BAD_SQL;
  }
  return BC_OK;
}

BCError bc_step (BCStmt stmt)
{
  int rc = sqlite3_step (stmt);
  if (rc && (rc != SQLITE_ROW) && (rc != SQLITE_DONE)) {
    bc_reset (stmt);
    bc_log (BC_BAD_SQL,
            "can not perform SQL step: %s",
            (const char*) sqlite3_errmsg(nodepool));
    return BC_BAD_SQL;
  }
  return (rc == SQLITE_ROW) ? BC_ROW : BC_OK;
}

BCError bc_reset (BCStmt stmt)
{
  if (sqlite3_reset (stmt)) {
    bc_log (BC_BAD_SQL,
            "can not perform SQL statement reset: %s",
            (const char*) sqlite3_errmsg(nodepool));
    return BC_BAD_SQL;
  }
  return BC_OK;
}

BCError bc_finalize (BCStmt stmt)
{
  if (sqlite3_finalize (stmt)) {
    printf ("finalize\n");
    bc_log (BC_BAD_SQL,
            "can not perform SQL statement finalize: %s",
            (const char*) sqlite3_errmsg(nodepool));
    return BC_BAD_SQL;
   }

   return BC_OK;
}

BCError bc_binds (BCStmt stmt, int position, const char *value)
{
  int rc = sqlite3_bind_text(stmt, position, value, -1, SQLITE_STATIC);
  if (rc) {
    bc_reset (stmt);
    bc_log (BC_BAD_SQL,
            "can not perform SQL string bind: %d: %s", rc,
            (const char*) sqlite3_errmsg(nodepool));
    return BC_BAD_SQL;
  }
  return BC_OK;
}

BCError bc_bindi (BCStmt stmt, int position, int value)
{
  if (sqlite3_bind_int(stmt, position, value)) {
    bc_reset (stmt);
    bc_log (BC_BAD_SQL,
            "can not perform SQL integer bind: %s",
            (const char*) sqlite3_errmsg(nodepool));
    return BC_BAD_SQL;
  }
  return BC_OK;
}

int bc_geti (BCStmt stmt, int column)
{
  return sqlite3_column_int(stmt, column);
}

char *bc_gets (BCStmt stmt, int column)
{
  return (char*) sqlite3_column_text (stmt, column);
}

/* get the name of a serializable table or return NULL otherwise */
char * bc_get_table_name (int table_id)
{
  static BCStmt stmt = NULL;
  char *table_name;

  /* get the table name: */
  if (!stmt)
    bc_sql (&stmt, "SELECT table_name FROM table_rules WHERE table_id=?");

  bc_bindi (stmt, 1, table_id);

  if (bc_step (stmt) != BC_ROW) { /* table not found */
    bc_finalize (stmt);
    stmt = NULL;
    return NULL;
  }

  table_name = strdup (bc_gets (stmt, 0));
  bc_reset (stmt);
  return table_name;
}

/* return the number of columns in a serialiable table given its id, 0 if
   the table does not exist or is not serializable */
int bc_num_columns (int table_id)
{
  return 0;
}

BCError bc_deserialize_row (int table_id, uint8_t *data, size_t length)
{
  BCStmt stmt;
  char *table_name;
  int pos;

  if ((table_name = (bc_get_table_name (table_id))) == NULL) { /* table not found */
    bc_log (BC_TABLE_NOT_SERIALIZABLE,
            "attempt to write to a non-serializable table with id %d", table_id);
    return BC_TABLE_NOT_SERIALIZABLE;
  }

  /* ubjson check this is an object */
  if (*data != '{') {
    bc_log (BC_BAD_DATA, "trying to deserialize something that is not a ubjson object");
    goto bad_data;
  }
  data++;

  /* check the number of columns in the table: */
  int num_columns = bc_num_columns (table_id);

  /* generate the insert: */

  /* bind values */
  for (pos = 1; *data!='}'; pos++) {
    if (pos > num_columns) {
      bc_finalize (stmt);
      bc_log (BC_BAD_DATA,
              "there is more data to deserialize than actual columns in the table %s",
              table_name);
      goto bad_data;
    }
    /* TODO: keep track of pointers */
    switch (*data) {

    case BC_MSG_INT32:
      bc_bindi (stmt, pos, *(int*)++data);
      data += 4;
      continue;

    case BC_MSG_STRING: {
      uint32_t size = *(uint32_t*)++data;
      if (length < size) { /* TODO: improve pointer checks */
        bc_finalize (stmt);
        bc_log (BC_BAD_DATA,
                "incorrect string size when deserializing to table %s", table_name);
        goto bad_data;
      }
      /* TODO: bc_bindns to use length for strings */
      data += sizeof (uint32_t);
      bc_binds (stmt, pos, (char*)data);
      data += size;
      continue;
    }

    case BC_MSG_FLOAT64:
      /*TODO*/
      continue;

    case BC_MSG_BLOB:
      /*TODO*/
      continue;

    default:
      /*TODO*/
      break;
    }
  }

  /* execute the inserction: */
  if (bc_step (stmt)) {
    /* get the error from sqlite (copy it because it may change after
       calling finalize): */
    char *err = strdup ((char*) sqlite3_errmsg (nodepool));
    bc_finalize (stmt);
    bc_log (BC_DB_ERROR,
            "error while deserializing in table %s: %s",
            table_name,
            err);
    free (table_name);
    free (err);
    return BC_DB_ERROR;
    /* TODO: ban system for nodes trying to cheat SQL checks */
  }

  bc_finalize (stmt);
  free (table_name);
  return BC_OK;

 bad_data:
  free (table_name);
  return BC_BAD_DATA;

}
